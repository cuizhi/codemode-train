; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\OBJ\usart.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\OBJ\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\CORE -I..\HARDWARE\KEY -I..\HARDWARE\LED -I..\HARDWARE\usart -I..\STM32F10x_FWLib\inc -I..\SYSTEM\sys -I..\USER -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x --omf_browse=..\OBJ\usart.crf ..\HARDWARE\usart\usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;8      /*-------------init----------*/
;;;9      void uart_init(void)
000000  b500              PUSH     {lr}
;;;10     {
000002  b085              SUB      sp,sp,#0x14
;;;11         GPIO_InitTypeDef GPIO_InitStructure;	
;;;12         USART_InitTypeDef USART_InitStructure;
;;;13         		
;;;14         /*----PeriphClock------------------------------------------------*/
;;;15         RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);   //串口USART2时钟开启
000004  2101              MOVS     r1,#1
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;16         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //串口USART2输入输出端口时钟开启
00000c  2101              MOVS     r1,#1
00000e  2004              MOVS     r0,#4
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;17     		
;;;18         /*----GPIO_InitStructure----------------------------------*/
;;;19         //USART1_TX:PA9
;;;20         GPIO_InitStructure.GPIO_Pin = GPIO_PIN_USART1TX;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;21         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0012          STRB     r0,[sp,#0x12]
;;;22         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出TX
000022  2018              MOVS     r0,#0x18
000024  f88d0013          STRB     r0,[sp,#0x13]
;;;23         GPIO_Init(GPIO_PORT_USART1TX, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4827              LDR      r0,|L1.200|
00002c  f7fffffe          BL       GPIO_Init
;;;24     	
;;;25         //USART1_RX:PA10
;;;26         GPIO_InitStructure.GPIO_Pin = GPIO_PIN_USART1RX;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;27         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000038  2003              MOVS     r0,#3
00003a  f88d0012          STRB     r0,[sp,#0x12]
;;;28         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //悬浮输入RX
00003e  2004              MOVS     r0,#4
000040  f88d0013          STRB     r0,[sp,#0x13]
;;;29         GPIO_Init(GPIO_PORT_USART1RX, &GPIO_InitStructure); 
000044  a904              ADD      r1,sp,#0x10
000046  4820              LDR      r0,|L1.200|
000048  f7fffffe          BL       GPIO_Init
;;;30     	
;;;31         /*------USART_InitStructure------------------------------*/
;;;32         USART_InitStructure.USART_BaudRate = 9600 ;
00004c  f44f5016          MOV      r0,#0x2580
000050  9000              STR      r0,[sp,#0]
;;;33         USART_InitStructure.USART_WordLength = USART_WordLength_8b ;
000052  2000              MOVS     r0,#0
000054  f8ad0004          STRH     r0,[sp,#4]
;;;34         USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
000058  f8ad0006          STRH     r0,[sp,#6]
;;;35         USART_InitStructure.USART_Parity = USART_Parity_No;
00005c  f8ad0008          STRH     r0,[sp,#8]
;;;36         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx ;
000060  200c              MOVS     r0,#0xc
000062  f8ad000a          STRH     r0,[sp,#0xa]
;;;37         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None ;
000066  2000              MOVS     r0,#0
000068  f8ad000c          STRH     r0,[sp,#0xc]
;;;38         USART_Init(USART1, &USART_InitStructure);
00006c  4669              MOV      r1,sp
00006e  4817              LDR      r0,|L1.204|
000070  f7fffffe          BL       USART_Init
;;;39     	
;;;40         USART_Cmd(USART1, ENABLE);
000074  2101              MOVS     r1,#1
000076  4815              LDR      r0,|L1.204|
000078  f7fffffe          BL       USART_Cmd
;;;41         /*--if use IT?-------*/
;;;42     	
;;;43         /*----other---------*/
;;;44     
;;;45     }
00007c  b005              ADD      sp,sp,#0x14
00007e  bd00              POP      {pc}
;;;46     
                          ENDP

                  serial_out PROC
;;;48     /*--------非阻塞的串口单字符发送、接收函数---*/
;;;49     bool serial_out(uint8_t chByte)
000080  b510              PUSH     {r4,lr}
;;;50     { 
000082  4604              MOV      r4,r0
;;;51         if(SET != USART_GetFlagStatus(USART1,USART_FLAG_TC)){
000084  2140              MOVS     r1,#0x40
000086  4811              LDR      r0,|L1.204|
000088  f7fffffe          BL       USART_GetFlagStatus
00008c  2801              CMP      r0,#1
00008e  d001              BEQ      |L1.148|
;;;52             return false;
000090  2000              MOVS     r0,#0
                  |L1.146|
;;;53         }
;;;54         USART_SendData(USART1,chByte);
;;;55     	
;;;56         return true;
;;;57     }
000092  bd10              POP      {r4,pc}
                  |L1.148|
000094  4621              MOV      r1,r4                 ;54
000096  480d              LDR      r0,|L1.204|
000098  f7fffffe          BL       USART_SendData
00009c  2001              MOVS     r0,#1                 ;56
00009e  e7f8              B        |L1.146|
;;;58     
                          ENDP

                  serial_in PROC
;;;59     bool serial_in(uint8_t *pchByte)
0000a0  b510              PUSH     {r4,lr}
;;;60     {
0000a2  4604              MOV      r4,r0
;;;61         if(NULL == pchByte){
0000a4  b90c              CBNZ     r4,|L1.170|
;;;62             return false;  
0000a6  2000              MOVS     r0,#0
                  |L1.168|
;;;63         }
;;;64         if(SET == USART_GetFlagStatus(USART1, USART_FLAG_RXNE)){
;;;65             *pchByte = USART_ReceiveData(USART1);
;;;66             return true;
;;;67         }else{
;;;68             return false;
;;;69         }
;;;70     }
0000a8  bd10              POP      {r4,pc}
                  |L1.170|
0000aa  2120              MOVS     r1,#0x20              ;64
0000ac  4807              LDR      r0,|L1.204|
0000ae  f7fffffe          BL       USART_GetFlagStatus
0000b2  2801              CMP      r0,#1                 ;64
0000b4  d105              BNE      |L1.194|
0000b6  4805              LDR      r0,|L1.204|
0000b8  f7fffffe          BL       USART_ReceiveData
0000bc  7020              STRB     r0,[r4,#0]            ;65
0000be  2001              MOVS     r0,#1                 ;66
0000c0  e7f2              B        |L1.168|
                  |L1.194|
0000c2  2000              MOVS     r0,#0                 ;68
0000c4  e7f0              B        |L1.168|
;;;71     
                          ENDP

0000c6  0000              DCW      0x0000
                  |L1.200|
                          DCD      0x40010800
                  |L1.204|
                          DCD      0x40013800
